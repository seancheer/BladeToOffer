#pragma once
#include "common.h"
#include "binary_tree.h"
#include "get_depth_of_binary_tree.h"
/************************************************************************/
/* 判断一颗二叉树是否为一个合法的avl
/************************************************************************/

/************************************************************************/
/* 思路1：
/* 计算出左儿子和右儿子的高度，然后判断高度差是否小于等于1，是的话，那么avl合法，否则，非法，
/* 然后进一步判断左子树和右子树，该方法需要重复遍历很多节点，因此效率不高                                           */
/************************************************************************/
bool is_a_valid_avl_simple(BinaryTree* header);



/************************************************************************/
/* 思路2：
/* 和思路1一致，采取后序遍历的方式，不同的是，使用一个变量depth来记录每次后续遍历后的高度，
/* 然后将该高度不断往上传，这样子就不需要重复遍历节点了
/************************************************************************/
bool is_a_valid_avl_by_depth(BinaryTree* header);

bool is_a_valid_avl_by_depth_internal(BinaryTree* header, int* depth);



/************************************************************************/
/* 开始算法
/************************************************************************/
void start_valid_avl();