#pragma once
#include "common.h"
#include "utils.h"
/************************************************************************/
/* 查找一个数组中最小的k个数，比如一个数组：4,5,1,6,2,7,3,8，那么最小的k个数为
/* 1,2,3,4
/************************************************************************/

/************************************************************************/
/* 基于partion的思路，源于快速排序的思想，由于每次的pivot总是被排序到了最终的位置，
/* 因此可以基于该思想求解该题。该解法适用于数据量比较小的时候。
/************************************************************************/
void find_smallest_k_num_partion(int* arr, int size, int k);

int smallest_k_num_partion(int* arr, int low, int high);


/************************************************************************/
/* 最容易想到的思路，适用于海量数据。
/* 思路：
/* 运用数据结构（比如队列或者红黑树）存储k个数，如果当前数据结构没有满，那么扫描到一个数字
/* 就放进去，否则的话，拿到当前数据结构中最大的数，如果扫描到的数比最大的数都大，那么继续扫描下一个
/* 否则，替换掉当前最大的数，最后把数据结构中的数挨个打印出来即可
/************************************************************************/
void find_smallest_k_num_many_data(int* arr, int size, int k);

//优先队列的比较方法
class SmallestKCompare {
public:
	bool operator()(const int& left, const int& right) const
	{
		return left > right;
	}
};

void start_find_smallest_k_num();
