#pragma once
#include  "common.h"
#include "utils.h"

/************************************************************************/
/* 寻找数组中出现次数超过数组长度一般的数字,注意，输入的数组中符合条件的数字只有一个
/* 最直观的解法：将数组进行排序，然后取数组的中位数，中位数一定是最终的结果，排序
/* 的时间复杂度为O(nlogn)，因此这里不采取
/************************************************************************/

/************************************************************************/
/* 解法一：通过快速排序的启发，每次partion的pivot的最终位置如果处于数组中位数的位置，
/* 那么这个值就是最终的结果，否则，如果处于中位数左边，那么对右边进行partition，否则
/* 对右边进行partition，直到找到最终的结果为止
/************************************************************************/
int solution_inspired_by_qsort(int *arr, int size);

int more_than_half_partition(int *arr, int low, int high);



/************************************************************************/
/* 解法2：通过一次迭代的方式就可以查找到出现次数大于一半的数字
/* 记录两个值，数字出现的次数times和某个数字number，当下一个数字和number相等时，
/* times + 1，如果不相等，减1，当为0的时候，将times设置为0，number记为下一个数字，
/* 那么当迭代完毕后，number所记录的数字即为超过一半的数字
/************************************************************************/
int solution_by_times_of_num(int* arr, int size);


/************************************************************************/
/* 算法入口
/************************************************************************/
void start_more_than_half();