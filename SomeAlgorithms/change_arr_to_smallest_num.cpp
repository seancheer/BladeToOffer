#include "change_arr_to_smallest_num.h"
/************************************************************************/
/* 把数组排成一个最小的数
/* 如：[3,32,321]组成的最小的数为321323
/************************************************************************/


/************************************************************************/
/* 解题思路：
/* 假设这么一种大小比较的方式，对于任意的数字m和n，如果拼接成的mn<nm，那么我们称之为
/* m < n，反之n > m和n == m，根据这种定义的大小的规则，我们对数组进行排序，最终排完序
/* 的结果就是答案，使用qsort进行排序，最终的时间复杂度为nlogn！！！
/* 一个很不错的解题思路，记住！！！
/************************************************************************/
void change_arr_to_smallest(int* arr, int size)
{
	if (NULL == arr || size <= 0)
	{
		puts("Invalid para!");
		return;
	}

	qsort(arr, size, sizeof(int), change_arr_compare);
	//按照顺序打印最后的结果
	puts("********************************************************************");
	for (int i = 0; i < size; ++i)
	{
		printf("%d", arr[i]);
	}
	puts("\n********************************************************************");
}


/************************************************************************/
/* 自定义的compare
/* 比较规则如下：对于任意的数字m和n，如果拼接成的mn<nm，那么我们称之为
/* m < n，反之n > m和n == m，
/************************************************************************/
int change_arr_compare(const void* left, const void* right)
{
	int* l_int = (int*)left;
	int* r_int = (int*)right;
	char l_str[10];
	memset(l_str, 0, 10);
	char r_str[10];
	memset(r_str, 0, 10);
	//把数字转换为字符串
	sprintf_s(l_str, "%d%d", *l_int, *r_int);
	sprintf_s(r_str, "%d%d", *r_int, *l_int);

	return strcmp(l_str, r_str);
}

/************************************************************************/
/* 开始算法
/************************************************************************/
void start_change_arr_to_smallest()
{
	const int size = 4;
	int arr[size] = { 3,32, 321, 2 };
	change_arr_to_smallest(arr, size);
}